# ポートフォリオマネージャー コード規約書（更新版3.0）

**バージョン:** 3.0  
**最終更新日時:** 2025/03/18 16:00

## 1. 概要

このドキュメントは、ポートフォリオマネージャーアプリケーションの開発に関する一貫したコーディング規約を定義します。すべての貢献者は、コードの品質、一貫性、保守性を確保するためにこれらの規約に従うものとします。

## 2. ファイル構造とプロジェクト編成

### 2.1 ディレクトリ構造

```
src/
├── components/      # UIコンポーネント
│   ├── auth/        # 認証関連コンポーネント 
│   ├── common/      # 共通UIコンポーネント
│   ├── dashboard/   # ダッシュボード画面コンポーネント
│   ├── data/        # データ連携コンポーネント
│   ├── layout/      # レイアウト関連コンポーネント
│   ├── settings/    # 設定画面コンポーネント
│   └── simulation/  # シミュレーション画面コンポーネント
├── context/         # React Context定義
├── hooks/           # カスタムReact Hooks
├── pages/           # ページコンポーネント
├── services/        # APIサービスとデータ処理
├── utils/           # ユーティリティ関数
└── App.jsx          # アプリケーションルート
```

### 2.2 ファイル命名規則

- **コンポーネントファイル**: PascalCase を使用（例: `PortfolioSummary.jsx`）
- **ユーティリティファイル**: camelCase を使用（例: `formatters.js`, `fundUtils.js`）
- **テストファイル**: `.test.js` または `.spec.js` を追加（例: `PortfolioSummary.test.jsx`）
- **CSS/SCSS**: コンポーネントと同じ名前で `.module.css` サフィックス（例: `Button.module.css`）
- **サーバーレス関数**: camelCase を使用し、機能を表す名前（例: `alpha-vantage-proxy.js`, `mof-exchange-rate-proxy.js`）

## 3. 命名規則

### 3.1 JSX コンポーネント

- **コンポーネント名**: PascalCase を使用
  ```jsx
  // 良い例
  function UserProfile() {...}
  const PortfolioChart = () => {...}
  
  // 悪い例
  function userProfile() {...}
  const portfolioChart = () => {...}
  ```

### 3.2 変数・関数名

- **変数・関数名**: camelCase を使用
  ```javascript
  // 良い例
  const userData = {...}
  function calculateTotal() {...}
  
  // 悪い例
  const UserData = {...}
  function CalculateTotal() {...}
  ```

- **boolean変数**: `is`, `has`, `should` などのプレフィックスを使用
  ```javascript
  // 良い例
  const isLoading = true;
  const hasError = false;
  const shouldRefresh = true;
  const isStock = true; // 個別株かどうかのフラグ
  const isInitialized = true; // 初期化完了フラグ
  const hasDividend = true; // 配当があるかどうかのフラグ（新規）
  const isDividendEstimated = true; // 配当情報が推定値かどうか（新規）
  ```

### 3.3 定数

- **定数**: 大文字のSNAKE_CASEを使用
  ```javascript
  // 良い例
  const MAX_RETRY_COUNT = 3;
  const DEFAULT_CURRENCY = 'JPY';
  const ALPHA_VANTAGE_URL = '/api/alpha-vantage-proxy';
  const FUND_TYPES = {
    STOCK: '個別株',
    ETF_JP: 'ETF（日本）',
    ETF_US: 'ETF（米国）'
  };
  // 配当頻度定数（新規）
  const DIVIDEND_FREQUENCY = {
    MONTHLY: 'monthly',
    QUARTERLY: 'quarterly',
    SEMI_ANNUAL: 'semi-annual',
    ANNUAL: 'annual',
    UNKNOWN: 'unknown'
  };
  ```

### 3.4 コンテキストとフック

- **コンテキスト**: `XxxContext` の形式を使用し、デフォルトエクスポート
  ```javascript
  // 良い例
  const AuthContext = createContext();
  export default AuthContext;
  export const AuthProvider = ({ children }) => {...};
  ```

- **カスタムフック**: `use` プレフィックスを使用し、両方のエクスポート形式を提供
  ```javascript
  // 良い例 - 両方のエクスポート形式
  export const useAuth = () => {...}
  export default useAuth;
  ```

### 3.5 イベントハンドラ

- **イベントハンドラ関数**: `handle` プレフィックスを使用
  ```javascript
  // 良い例
  const handleSubmit = () => {...}
  const handleInputChange = (e) => {...}
  const handleIncrementFee = (asset, amount) => {...}
  const handleSaveToLocalStorage = () => {...} // ローカルストレージ保存ハンドラ
  const handleUpdateDividendInfo = (asset, yield) => {...} // 配当情報更新ハンドラ（新規）
  ```

### 3.6 ユーティリティ関数

- **ユーティリティ関数**: 目的が明確な名前を使用
  ```javascript
  // 良い例
  const formatCurrency = (amount, currency) => {...}
  const estimateAnnualFee = (ticker, name) => {...}
  const guessFundType = (ticker, name) => {...}
  const encryptData = (data) => {...} // データ暗号化関数
  const decryptData = (encrypted) => {...} // データ復号化関数
  const estimateDividendYield = (ticker, name) => {...} // 配当利回り推定関数（新規）
  const calculateAnnualDividend = (asset, exchangeRate, baseCurrency) => {...} // 年間配当金計算関数（新規）
  const formatDividendFrequency = (frequency) => {...} // 配当頻度の表示変換関数（新規）
  const determineHasDividend = (ticker, fundType) => {...} // 配当の有無判定関数（新規）
  ```

## 4. コードフォーマット

### 4.1 基本ルール

- **インデント**: 2スペースを使用
- **行の長さ**: 最大100文字（例外：URLs、長い文字列）
- **セミコロン**: すべての文の末尾にセミコロンを使用
- **括弧のスタイル**: 開始括弧は同じ行に配置

### 4.2 JSX フォーマット

- **要素の属性が多い場合**: 複数行に分割
  ```jsx
  // 良い例 (少数の属性)
  <Button type="primary" onClick={handleClick}>提出</Button>
  
  // 良い例 (多数の属性)
  <Button
    type="button"
    className={`px-4 py-2 rounded-md ${
      importFormat === 'json' ? 'bg-primary text-white' : 'bg-gray-200'
    }`}
    onClick={() => setImportFormat('json')}
    role="radio"
    aria-checked={importFormat === 'json'}
    disabled={isStock} // 個別株の場合は無効化
  >
    JSON
  </Button>
  ```

- **バッジコンポーネント**:
  ```jsx
  // ファンドタイプバッジ
  <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
    asset.fundType === FUND_TYPES.STOCK
      ? 'bg-gray-100 text-gray-800'
      : 'bg-blue-100 text-blue-800'
  }`}>
    {asset.fundType}
  </span>
  
  // 手数料情報バッジ
  <span className={`text-xs px-1.5 py-0.5 rounded ${
    asset.feeSource === '個別株'
      ? 'bg-gray-100 text-gray-800'
      : asset.feeSource === 'ユーザー設定' 
        ? 'bg-purple-100 text-purple-800' 
        : asset.feeIsEstimated 
          ? 'bg-yellow-100 text-yellow-800'
          : 'bg-green-100 text-green-800'
  }`}>
    {asset.feeSource}
  </span>
  
  // データソースバッジ
  <span className={`text-xs px-1.5 py-0.5 rounded ${
    dataSource === 'cloud'
      ? 'bg-blue-100 text-blue-800'
      : 'bg-amber-100 text-amber-800'
  }`}>
    {dataSource === 'cloud' ? 'クラウド' : 'ローカル'}
  </span>
  
  // 配当情報バッジ（新規）
  <span className={`text-xs px-1.5 py-0.5 rounded ${
    !asset.hasDividend
      ? 'bg-gray-100 text-gray-800'
      : asset.dividendIsEstimated 
        ? 'bg-yellow-100 text-yellow-800'
        : 'bg-green-100 text-green-800'
  }`}>
    {!asset.hasDividend 
      ? '配当なし' 
      : formatDividendFrequency(asset.dividendFrequency) + (asset.dividendIsEstimated ? '（推定）' : '')}
  </span>
  ```

- **アクセシビリティ属性**:
  ```jsx
  // ラベルとコントロールの関連付け
  <label htmlFor="budget-input">追加予算</label>
  <input id="budget-input" type="number" />
  
  // ラジオグループ
  <div role="radiogroup" aria-labelledby="format-label">
    <span id="format-label">形式:</span>
    <button role="radio" aria-checked={true}>JSON</button>
    <button role="radio" aria-checked={false}>CSV</button>
  </div>
  ```

### 4.3 インポート文の整理

- **インポートの順序**:
  1. React関連（React, React Router）
  2. サードパーティライブラリ
  3. プロジェクト内モジュール（相対パス）
  4. ユーティリティとタイプ
  5. スタイル・アセット

  ```javascript
  // 良い例
  import React, { useState, useCallback, useRef } from 'react';
  import { useNavigate } from 'react-router-dom';
  
  import jwtDecode from 'jwt-decode';
  import { formatCurrency } from 'accounting';
  
  import { usePortfolioContext } from '../../hooks/usePortfolioContext';
  import Header from '../layout/Header';
  
  import { FUND_TYPES, DIVIDEND_FREQUENCY } from '../../utils/fundUtils';
  
  import './styles.css';
  ```

## 5. React固有の規則

### 5.1 コンポーネント定義

- **関数コンポーネント**: アロー関数よりも関数宣言を優先
  ```jsx
  // 推奨
  function MyComponent() {
    return <div>...</div>;
  }
  ```

- **Props分割代入**: コンポーネント内で使用
  ```jsx
  // 良い例
  function UserCard({ name, email, avatar, isStock, hasDividend }) {
    return (
      <div>
        <img src={avatar} alt={name} />
        <h2>{name}</h2>
        <p>{email}</p>
        {isStock && <span className="badge">個別株</span>}
        {hasDividend && <span className="badge">配当あり</span>}
      </div>
    );
  }
  ```

### 5.2 Hooks の使用

- **useCallback, useMemo**: 適切に依存配列を定義
  ```jsx
  // 良い例
  const handleSubmit = useCallback(() => {
    submitData(formData);
  }, [formData, submitData]);
  
  // 良い例 - 初期化完了後のみ実行
  useEffect(() => {
    if (initialized) {
      updateExchangeRate();
    }
  }, [initialized, updateExchangeRate]);
  ```

- **カスタムフックの命名**: 明確な目的を表す名前を使用
  ```jsx
  // 良い例
  export const usePortfolioContext = () => {...}
  export const useAuth = () => {...}
  export const useFundUtils = () => {...}
  export const useLocalStorage = () => {...} // ローカルストレージ操作フック
  export const useDividendCalculation = () => {...} // 配当計算フック（新規）
  ```

### 5.3 環境依存のライブラリ対応

- **jwt-decode v4の対応**: デフォルトインポートを使用
  ```javascript
  // jwt-decode v3/v4対応
  import jwtDecode from 'jwt-decode';
  
  // 使用例
  const decodedToken = jwtDecode(token);
  ```

### 5.4 コンテキスト間の連携

- **循環参照の回避**: useRefを使用して一方向参照を実装
  ```javascript
  // 良い例
  const portfolioContextRef = useRef(null);
  
  // 参照設定関数
  const setPortfolioContextRef = useCallback((context) => {
    portfolioContextRef.current = context;
  }, []);
  
  // 参照使用
  if (portfolioContextRef.current?.handleAuthStateChange) {
    portfolioContextRef.current.handleAuthStateChange(true, user);
  }
  ```

- **専用コネクタコンポーネント**: App.jsxに配置して両方のコンテキストを接続
  ```javascript
  // 良い例
  const ContextConnector = () => {
    const auth = useAuth();
    const portfolio = usePortfolioContext();
    
    useEffect(() => {
      if (auth?.setPortfolioContextRef && portfolio) {
        auth.setPortfolioContextRef(portfolio);
      }
    }, [auth, portfolio]);
    
    return null;
  };
  ```

### 5.5 エラーバウンダリの使用

- **アプリケーション全体を保護**: エラーバウンダリでラップしてクラッシュ耐性を向上
  ```javascript
  // 良い例
  class ErrorBoundary extends React.Component {
    constructor(props) {
      super(props);
      this.state = { hasError: false, error: null };
    }
    
    static getDerivedStateFromError(error) {
      return { hasError: true, error };
    }
    
    componentDidCatch(error, errorInfo) {
      console.error('アプリケーションエラー:', error, errorInfo);
    }
    
    render() {
      if (this.state.hasError) {
        return <エラー表示コンポーネント error={this.state.error} />;
      }
      return this.props.children;
    }
  }
  
  // 使用方法
  function App() {
    return (
      <ErrorBoundary>
        <アプリケーションコンポーネント />
      </ErrorBoundary>
    );
  }
  ```

## 6. 状態管理

### 6.1 Context API の使用

- **コンテキスト分離**: 関連する状態ごとに別々のコンテキストを使用
  - AuthContext: 認証関連
  - PortfolioContext: ポートフォリオデータ関連

- **Provider のカプセル化**: 専用のProviderコンポーネントを作成
  ```jsx
  export const AuthProvider = ({ children }) => {
    // 状態と関数の定義
    return (
      <AuthContext.Provider value={...}>
        {children}
      </AuthContext.Provider>
    );
  };
  ```

### 6.2 状態更新関数

- **イミュータブルな更新**: 常に新しいオブジェクトを返す
  ```javascript
  // 良い例
  setCurrentAssets(prev => 
    prev.map(item => 
      item.id === id 
      ? { ...item, holdings: parseFloat(parseFloat(holdings).toFixed(4)) || 0 } 
      : item
    )
  );
  ```

- **小数点位置の処理**: 数値の精度を保つために適切な方法を使用
  ```javascript
  // 小数点以下4桁まで保存するケース
  const value = parseFloat(parseFloat(rawValue).toFixed(4));
  
  // 小数点以下2桁まで保存するケース（手数料率など）
  const fee = parseFloat(parseFloat(rawValue).toFixed(2));
  
  // 小数点以下2桁まで保存するケース（配当利回りなど）（新規）
  const yield = parseFloat(parseFloat(rawValue).toFixed(2));
  ```

- **条件付き状態更新**: 条件に基づいて異なる更新を行う
  ```javascript
  // 個別株判定に基づく状態更新
  setCurrentAssets(prev => 
    prev.map(item => {
      if (item.id === id) {
        if (item.fundType === FUND_TYPES.STOCK || item.isStock) {
          // 個別株の場合は手数料を強制的に0に設定
          return {
            ...item,
            annualFee: 0,
            feeSource: '個別株',
            feeIsEstimated: false
          };
        } else {
          // その他のファンドの場合はユーザー指定の値を使用
          return {
            ...item,
            annualFee: parseFloat(parseFloat(fee).toFixed(2)) || 0,
            userSetFee: true,
            feeSource: 'ユーザー設定',
            feeIsEstimated: false
          };
        }
      }
      return item;
    })
  );
  ```

- **配当情報の更新**: 配当情報の更新処理（新規）
  ```javascript
  // 配当情報の更新
  const updateDividendInfo = useCallback((id, dividendYield, hasDividend = true, frequency = 'quarterly') => {
    setCurrentAssets(prev => {
      const updated = prev.map(item => {
        if (item.id === id) {
          return {
            ...item,
            dividendYield: parseFloat(parseFloat(dividendYield).toFixed(2)) || 0,
            hasDividend: hasDividend,
            dividendFrequency: frequency,
            dividendIsEstimated: false
          };
        }
        return item;
      });
      
      // 変更後に自動保存
      setTimeout(() => saveToLocalStorage(), 100);
      return updated;
    });
  }, [saveToLocalStorage]);
  ```

- **状態更新後の処理**: setTimeout を使用して順序を確保
  ```javascript
  // 良い例
  setTargetPortfolio(prev => {
    const updated = prev.map(item => 
      item.id === id ? { ...item, targetPercentage: parseFloat(percentage) } : item
    );
    // 変更後に自動保存
    setTimeout(() => saveToLocalStorage(), 100);
    return updated;
  });
  ```

### 6.3 ローカルストレージとの連携

- **データの暗号化**: URIエンコーディングを含むBase64エンコーディングによる安全な暗号化（改良版）
  ```javascript
  // 改良版 - 特殊文字にも対応
  const encryptData = (data) => {
    try {
      const jsonString = JSON.stringify(data);
      return btoa(encodeURIComponent(jsonString)); // URI化してからBase64エンコード
    } catch (error) {
      console.error('データの暗号化に失敗しました', error);
      return null;
    }
  };
  
  const decryptData = (encryptedData) => {
    try {
      const jsonString = decodeURIComponent(atob(encryptedData)); // Base64デコードしてからURI復号
      return JSON.parse(jsonString);
    } catch (error) {
      console.error('データの復号化に失敗しました', error);
      // フォールバック処理 - 古い形式を試行
      try {
        const jsonString = atob(encryptedData);
        return JSON.parse(jsonString);
      } catch (fallbackError) {
        console.error('フォールバック復号化も失敗しました', fallbackError);
        return null;
      }
    }
  };
  ```

- **保存・読み込み関数**: useCallbackを使用して依存関係を管理
  ```javascript
  // 良い例 - 強化版エラーハンドリング
  const saveToLocalStorage = useCallback(() => {
    if (!initialized) return false; // 初期化前は保存しない
    
    try {
      const portfolioData = {
        baseCurrency,
        exchangeRate,
        lastUpdated,
        currentAssets,
        targetPortfolio,
        additionalBudget,
        version: '1.0.0',
        timestamp: new Date().toISOString()
      };
      
      const encryptedData = encryptData(portfolioData);
      if (!encryptedData) {
        throw new Error('データの暗号化に失敗しました');
      }
      
      localStorage.setItem('portfolioData', encryptedData);
      
      return true;
    } catch (error) {
      console.error('ローカルストレージへの保存に失敗しました', error);
      addNotification('データの保存に失敗しました', 'error');
      return false;
    }
  }, [initialized, /* 依存する状態変数 */]);
  ```

- **読み込み関数**: 強化されたエラーハンドリングと検証
  ```javascript
  const loadFromLocalStorage = useCallback(() => {
    try {
      console.log('ローカルストレージからのデータ読み込みを試行...');
      const encryptedData = localStorage.getItem('portfolioData');
      
      if (!encryptedData) {
        console.log('ローカルストレージにデータがありません');
        return null;
      }
      
      const decryptedData = decryptData(encryptedData);
      if (!decryptedData) {
        console.log('データの復号化に失敗しました');
        return null;
      }
      
      // 基本的なデータ構造の検証
      const requiredFields = ['baseCurrency', 'currentAssets', 'targetPortfolio'];
      const missingFields = requiredFields.filter(field => !(field in decryptedData));
      
      if (missingFields.length > 0) {
        console.warn(`復号化されたデータに必須フィールドがありません: ${missingFields.join(', ')}`);
        return null;
      }
      
      return decryptedData;
    } catch (error) {
      console.error('ローカルストレージからの読み込みに失敗しました', error);
      return null;
    }
  }, []);
  ```

### 6.4 Google Drive連携

- **アクセストークン管理**: 認証トークンとアクセストークンの管理
  ```javascript
  // アクセストークンの保存用変数
  let accessToken = null;
  
  // アクセストークンを設定する関数
  export function setGoogleAccessToken(token) {
    console.log('[API] Setting Google access token');
    if (token) {
      accessToken = token;
      console.log('[API] Access token set successfully');
    }
  }
  
  // 新しいアクセストークンを取得する関数
  async function getGoogleAccessToken() {
    return new Promise((resolve, reject) => {
      try {
        if (window.google && window.google.accounts && window.google.accounts.oauth2) {
          const tokenClient = window.google.accounts.oauth2.initTokenClient({
            client_id: GOOGLE_CLIENT_ID,
            scope: 'https://www.googleapis.com/auth/drive.file',
            callback: (tokenResponse) => {
              if (tokenResponse && tokenResponse.access_token) {
                console.log('[API] New access token acquired');
                resolve(tokenResponse.access_token);
              } else {
                console.warn('[API] No access token in response');
                resolve(null);
              }
            },
            error_callback: (error) => {
              console.error('[API] Error getting token:', error);
              reject(error);
            }
          });
          
          // トークンをリクエスト
          tokenClient.requestAccessToken({ prompt: '' });
        } else {
          console.warn('[API] Google OAuth API not available');
          resolve(null);
        }
      } catch (error) {
        console.error('[API] Error in getGoogleAccessToken:', error);
        reject(error);
      }
    });
  }
  ```

## 7. エラー処理

### 7.1 エラーキャッチと表示

- **try/catch**: 非同期処理では常に使用
  ```javascript
  try {
    const data = await fetchData();
    processData(data);
  } catch (error) {
    console.error('データ取得エラー:', error);
    setError('データの取得に失敗しました');
  }
  ```

- **ログ出力の強化**: デバッグ情報を十分に提供
  ```javascript
  try {
    console.log(`Attempting to fetch data for ${ticker} from Alpha Vantage`);
    const response = await axios.get(ALPHA_VANTAGE_URL, {
      params: { symbols: ticker },
      timeout: 5000 // タイムアウト設定
    });
    // 処理
  } catch (error) {
    console.error(`Error fetching ${ticker} from Alpha Vantage:`, error);
    console.log(`Trying fallback for ${ticker}`);
    // 代替処理
  }
  ```

### 7.2 入力バリデーション

- **早期リターン**: エラーケースを最初に処理
  ```javascript
  const submitForm = (data) => {
    if (!data.email) {
      setError('メールアドレスは必須です');
      return;
    }
    
    // 正常処理を続行
  };
  ```

- **特殊条件のチェック**:
  ```javascript
  // 個別株の手数料編集防止
  const handleIncrementFee = (asset, amount) => {
    // 個別株は手数料の変更不可
    if (asset.fundType === FUND_TYPES.STOCK || asset.isStock) {
      showMessage('個別株の手数料率は変更できません（常に0%）', 'warning');
      return;
    }
    
    // 通常の処理を続行
    const newValue = Math.max(0, (asset.annualFee || 0) + amount);
    updateAnnualFee(asset.id, parseFloat(newValue.toFixed(2)));
  };
  ```

- **初期化状態のチェック**:
  ```javascript
  // 良い例 - 初期化前は保存しない
  const saveToLocalStorage = useCallback(() => {
    if (!initialized) return false;
    
    // 保存処理を続行
  }, [initialized, /* その他の依存関係 */]);
  ```

### 7.3 API呼び出しのフォールバック処理

- **Alpha Vantage API使用とフォールバック**:
  ```javascript
  // Alpha Vantage APIからのデータ取得を試みる
  try {
    const result = await fetchFromAlphaVantage(ticker);
    return result;
  } catch (error) {
    console.error('Alpha Vantage API error:', error);
    
    // APIからのデータ取得に失敗した場合はフォールバック値を使用
    return generateFallbackData(ticker);
  }
  ```

- **タイムアウト設定**:
  ```javascript
  // タイムアウト付きの呼び出し
  const response = await axios.get(apiUrl, {
    params: { /* パラメータ */ },
    timeout: 15000 // 15秒タイムアウト
  });
  ```

### 7.4 データ永続化エラー処理

- **暗号化/復号化エラー**:
  ```javascript
  // データの復号化 - 改良版エラーハンドリング
  const decryptData = (encryptedData) => {
    try {
      const jsonString = decodeURIComponent(atob(encryptedData));
      return JSON.parse(jsonString);
    } catch (error) {
      console.error('データの復号化に失敗しました', error);
      
      // フォールバック処理 - 古い形式を試行
      try {
        const jsonString = atob(encryptedData);
        return JSON.parse(jsonString);
      } catch (fallbackError) {
        console.error('フォールバック復号化も失敗しました', fallbackError);
        return null;
      }
    }
  };
  ```

### 7.5 エラーバウンダリの導入

- **コンポーネントレベルのエラー処理**:
  ```javascript
  // アプリケーション全体のエラーバウンダリ
  class ErrorBoundary extends React.Component {
    constructor(props) {
      super(props);
      this.state = { hasError: false, error: null };
    }
    
    static getDerivedStateFromError(error) {
      return { hasError: true, error };
    }
    
    componentDidCatch(error, errorInfo) {
      console.error('アプリケーションエラー:', error, errorInfo);
    }
    
    render() {
      if (this.state.hasError) {
        return (
          <div className="min-h-screen flex items-center justify-center bg-gray-100">
            <div className="bg-white p-6 rounded-lg shadow-md max-w-md">
              <h2 className="text-red-600 text-xl mb-4">エラーが発生しました</h2>
              <p className="mb-2">申し訳ありませんが、アプリケーションにエラーが発生しました。</p>
              <p className="text-gray-700 mb-4">詳細: {this.state.error?.message || '不明なエラー'}</p>
              <button
                className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
                onClick={() => window.location.reload()}
              >
                リロードする
              </button>
            </div>
          </div>
        );
      }
      
      return this.props.children;
    }
  }
  ```

## 8. Google Drive API連携

### 8.1 ファイル操作関数

- **ファイル保存関数**: 
  ```javascript
  export async function saveToGoogleDrive(data, userData, filename = 'portfolio_data.json') {
    if (!userData || !userData.email) {
      return { success: false, message: 'ユーザー情報がありません' };
    }
    
    try {
      // 新しいアクセストークンを取得
      const newToken = await getGoogleAccessToken();
      if (!newToken) {
        return { success: false, message: 'アクセストークンの取得に失敗しました' };
      }
      
      // メタデータとファイル内容の準備
      const metadata = {
        name: filename,
        mimeType: 'application/json'
      };
      
      // JSONデータを文字列に変換
      const jsonContent = JSON.stringify(data);
      const blob = new Blob([jsonContent], { type: 'application/json' });
      
      // FormDataオブジェクトを作成
      const formData = new FormData();
      formData.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
      formData.append('file', blob);
      
      // APIリクエストを実行
      const response = await fetch(
        'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart',
        {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${newToken}`
          },
          body: formData
        }
      );
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP error ${response.status}: ${errorText}`);
      }
      
      const result = await response.json();
      
      return {
        success: true,
        message: 'データを保存しました',
        fileId: result.id,
        fileName: result.name
      };
    } catch (error) {
      console.error('[API] Error saving to Google Drive:', error);
      return { 
        success: false, 
        message: `Googleドライブへの保存に失敗しました: ${error.message}` 
      };
    }
  }
  ```

- **ファイル読み込み関数**:
  ```javascript
  export async function loadFromGoogleDrive(userData, filename = 'portfolio_data.json') {
    if (!userData || !userData.email) {
      return { success: false, message: 'ユーザー情報がありません' };
    }
    
    try {
      // 新しいアクセストークンを取得
      const newToken = await getGoogleAccessToken();
      if (!newToken) {
        return { success: false, message: 'アクセストークンの取得に失敗しました' };
      }
      
      // ファイルを検索するクエリを構築
      const query = encodeURIComponent(`name='${filename}' and trashed=false`);
      
      // ファイル検索APIを呼び出し
      const searchResponse = await fetch(
        `https://www.googleapis.com/drive/v3/files?q=${query}`,
        {
          headers: {
            'Authorization': `Bearer ${newToken}`
          }
        }
      );
      
      if (!searchResponse.ok) {
        const errorText = await searchResponse.text();
        throw new Error(`検索エラー ${searchResponse.status}: ${errorText}`);
      }
      
      const searchResult = await searchResponse.json();
      
      // ファイルが見つからない場合
      if (!searchResult.files || searchResult.files.length === 0) {
        return { success: false, message: 'ファイルが見つかりません' };
      }
      
      // 最新のファイルを取得
      const fileId = searchResult.files[0].id;
      
      // ファイルの内容を取得
      const fileResponse = await fetch(
        `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`,
        {
          headers: {
            'Authorization': `Bearer ${newToken}`
          }
        }
      );
      
      if (!fileResponse.ok) {
        const errorText = await fileResponse.text();
        throw new Error(`ファイル取得エラー ${fileResponse.status}: ${errorText}`);
      }
      
      // レスポンスをJSONとしてパース
      const data = await fileResponse.json();
      
      return {
        success: true,
        message: 'データを読み込みました',
        data: data,
        fileId: fileId,
        fileName: filename
      };
    } catch (error) {
      console.error('[API] Error loading from Google Drive:', error);
      return { 
        success: false, 
        message: `Googleドライブからの読み込みに失敗しました: ${error.message}` 
      };
    }
  }
  ```

### 8.2 認証関連の処理

- **認証トークン処理**:
  ```javascript
  // ログイン処理
  const handleLogin = useCallback((credentialResponse) => {
    try {
      // IDトークンをデコード
      const decodedToken = jwtDecode(credentialResponse.credential);
      
      // トークンを保存
      setGoogleToken(credentialResponse.credential);
      
      const userData = {
        name: decodedToken.name,
        email: decodedToken.email,
        picture: decodedToken.picture
      };
      
      setUser(userData);
      setIsAuthenticated(true);
      
      // トークンをローカルストレージに保存
      localStorage.setItem('googleToken', credentialResponse.credential);
      
      // API層にもトークンを設定
      setGoogleAccessToken(credentialResponse.credential);
      
      // コンテキスト間の連携設定
      if (portfolioContextRef.current) {
        if (portfolioContextRef.current.handleAuthStateChange) {
          portfolioContextRef.current.handleAuthStateChange(true, userData);
        }
        
        // 遅延してからデータ読み込みを試行
        setTimeout(() => {
          if (portfolioContextRef.current.loadFromGoogleDrive) {
            portfolioContextRef.current.loadFromGoogleDrive(userData);
          }
        }, 1000);
      }
    } catch (error) {
      console.error('ログインエラー:', error);
    }
  }, []);
  ```

## 9. アクセシビリティ

### 9.1 基本原則

- **意味的なHTML**: 適切なHTML要素や属性を使用
  ```jsx
  // 良い例
  <button 
    type="button"
    onClick={handleClick}
    aria-label="閉じる"
    disabled={isDisabled}
  >
    <Icon name="close" />
  </button>
  ```

### 9.2 フォームアクセシビリティ

- **ラベル関連付け**: フォーム要素にはlabelを関連付け
  ```jsx
  // 良い例
  <div>
    <label htmlFor="email">メールアドレス</label>
    <input id="email" type="email" />
  </div>
  ```

- **グループ化と関連付け**: ラジオボタンなどのグループは適切に構造化
  ```jsx
  <div role="radiogroup" aria-labelledby="format-label">
    <span id="format-label">フォーマット:</span>
    <button role="radio" aria-checked={format === 'json'}>JSON</button>
    <button role="radio" aria-checked={format === 'csv'}>CSV</button>
  </div>
  ```

## 10. 配当情報関連の実装（新規）

### 10.1 配当情報の取得・計算

- **配当情報の推定関数**:
  ```javascript
  // 配当利回りを推定する関数
  export function estimateDividendYield(ticker, name = '') {
    if (!ticker) return {
      yield: 0,
      isEstimated: true,
      hasDividend: false,
      dividendFrequency: 'unknown'
    };
    
    ticker = ticker.toUpperCase();
    const info = extractFundInfo(ticker, name);
    
    // 基本的な推定値
    let estimatedYield = 0;
    let isEstimated = true;
    let hasDividend = info.hasDividend || false;
    
    // 特定のティッカーに対する配当利回り情報があれば使用
    if (TICKER_SPECIFIC_DIVIDENDS[ticker] !== undefined) {
      estimatedYield = TICKER_SPECIFIC_DIVIDENDS[ticker];
      isEstimated = false;
      hasDividend = estimatedYield > 0;
    } else {
      // ファンドタイプに基づく推定
      const fundType = info.fundType;
      
      if (fundType === FUND_TYPES.STOCK) {
        // 個別株の場合は配当情報を持たないと仮定（推定困難のため、後でデータを更新）
        estimatedYield = 0;
        hasDividend = false;
      } else if (fundType === FUND_TYPES.REIT_US) {
        estimatedYield = 4.0; // 米国REITの平均
        hasDividend = true;
      } else if (fundType === FUND_TYPES.REIT_JP) {
        estimatedYield = 3.5; // 日本REITの平均
        hasDividend = true;
      } else if (fundType === FUND_TYPES.BOND) {
        estimatedYield = 2.5; // 債券ファンドの平均
        hasDividend = true;
      } else if (
        name.includes('dividend') || 
        name.includes('配当') || 
        name.includes('income') || 
        name.includes('yield') ||
        name.includes('高配当')
      ) {
        // 名前から高配当と推測される場合
        estimatedYield = 3.0;
        hasDividend = true;
      } else if (fundType === FUND_TYPES.ETF_US) {
        estimatedYield = 1.5; // 米国ETFの平均
        hasDividend = true;
      } else if (fundType === FUND_TYPES.ETF_JP) {
        estimatedYield = 1.8; // 日本ETFの平均
        hasDividend = true;
      } else if (fundType === FUND_TYPES.INDEX_US) {
        estimatedYield = 1.5; // 米国インデックスファンドの平均
        hasDividend = true;
      } else if (fundType === FUND_TYPES.INDEX_JP) {
        estimatedYield = 1.2; // 日本インデックスファンドの平均
        hasDividend = true;
      } else {
        estimatedYield = 1.0; // その他のファンドのデフォルト値
        hasDividend = estimatedYield > 0;
      }
    }
    
    return {
      yield: estimatedYield,
      isEstimated: isEstimated,
      hasDividend: hasDividend,
      dividendFrequency: info.dividendFrequency || 'quarterly' // デフォルトは四半期
    };
  }
  ```

- **年間配当金の計算**:
  ```javascript
  // 年間配当金の計算
  const annualDividends = currentAssets.reduce((sum, asset) => {
    // 配当がない場合はスキップ
    if (!asset.hasDividend) {
      return sum;
    }
    
    let assetValue = asset.price * asset.holdings;
    
    // 通貨換算
    if (asset.currency !== baseCurrency) {
      if (baseCurrency === 'JPY' && asset.currency === 'USD') {
        assetValue *= exchangeRate.rate;
      } else if (baseCurrency === 'USD' && asset.currency === 'JPY') {
        assetValue /= exchangeRate.rate;
      }
    }
    
    return sum + (assetValue * (asset.dividendYield || 0) / 100);
  }, 0);
  ```

### 10.2 配当情報の表示

- **配当情報バッジ**:
  ```jsx
  // 配当情報バッジ
  <span className={`text-xs px-1.5 py-0.5 rounded ${
    !asset.hasDividend
      ? 'bg-gray-100 text-gray-800'
      : asset.dividendIsEstimated 
        ? 'bg-yellow-100 text-yellow-800'
        : 'bg-green-100 text-green-800'
  }`}>
    {!asset.hasDividend 
      ? '配当なし' 
      : formatDividendFrequency(asset.dividendFrequency) + (asset.dividendIsEstimated ? '（推定）' : '')}
  </span>
  ```

- **配当頻度の表示変換**:
  ```javascript
  // 配当頻度の表示変換
  const formatDividendFrequency = (frequency) => {
    switch (frequency) {
      case 'monthly': return '毎月';
      case 'quarterly': return '四半期';
      case 'semi-annual': return '半年';
      case 'annual': return '年1回';
      default: return '不明';
    }
  };
  ```

- **配当情報の要約表示**:
  ```jsx
  // 配当情報の要約表示
  <div className="bg-green-50 p-4 rounded-lg">
    <p className="text-sm text-gray-500 mb-1">年間配当金（推定）</p>
    <div>
      <p className="text-2xl font-bold text-green-600">
        {formatCurrency(annualDividends, baseCurrency)}
      </p>
      <p className="text-sm text-gray-500">
        （配当利回り{formatPercent(dividendYieldPercentage, 2)}）
      </p>
    </div>
  </div>
  ```

## 改訂履歴

| バージョン | 日付 | 変更内容 | 担当者 |
|----------|-----|---------|-------|
| 1.0      | 2025/03/06 10:30 | 初版作成 | |
| 1.1      | 2025/03/08 13:45 | jwt-decode対応、アクセシビリティ対応、ESLint設定更新 | |
| 1.2      | 2025/03/10 09:15 | データ取得フォールバック機構、環境変数名統一、ログ出力強化 | |
| 1.3      | 2025/03/12 16:25 | ファンドタイプ判定と年間手数料計算に関する規約追加、個別株の取り扱い追加 | |
| 1.4      | 2025/03/15 10:50 | ローカルストレージによるデータ永続化、コンテキスト間連携、React Hooksルール強化 | |
| 2.0      | 2025/03/17 18:45 | 暗号化/復号化処理の強化、エラーハンドリング改善、Google Drive API連携機能の実装、エラーバウンダリ導入 | |
| 3.0      | 2025/03/18 16:00 | 配当情報関連の変数と関数の命名規則、配当情報の表示・計算機能の実装規則、コンポーネントスタイルの更新 | |
