# ポートフォリオマネージャー コード規約書（更新版）

**バージョン:** 1.3  
**最終更新日:** 2025/03/20

## 1. 概要

このドキュメントは、ポートフォリオマネージャーアプリケーションの開発に関する一貫したコーディング規約を定義します。すべての貢献者は、コードの品質、一貫性、保守性を確保するためにこれらの規約に従うものとします。

## 2. ファイル構造とプロジェクト編成

### 2.1 ディレクトリ構造

```
src/
├── components/      # UIコンポーネント
│   ├── auth/        # 認証関連コンポーネント 
│   ├── common/      # 共通UIコンポーネント
│   ├── dashboard/   # ダッシュボード画面コンポーネント
│   ├── data/        # データ連携コンポーネント
│   ├── layout/      # レイアウト関連コンポーネント
│   ├── settings/    # 設定画面コンポーネント
│   └── simulation/  # シミュレーション画面コンポーネント
├── context/         # React Context定義
├── hooks/           # カスタムReact Hooks
├── pages/           # ページコンポーネント
├── services/        # APIサービスとデータ処理
├── utils/           # ユーティリティ関数
└── App.jsx          # アプリケーションルート
```

### 2.2 ファイル命名規則

- **コンポーネントファイル**: PascalCase を使用（例: `PortfolioSummary.jsx`）
- **ユーティリティファイル**: camelCase を使用（例: `formatters.js`, `fundUtils.js`）
- **テストファイル**: `.test.js` または `.spec.js` を追加（例: `PortfolioSummary.test.jsx`）
- **CSS/SCSS**: コンポーネントと同じ名前で `.module.css` サフィックス（例: `Button.module.css`）
- **サーバーレス関数**: camelCase を使用し、機能を表す名前（例: `alpha-vantage-proxy.js`, `mof-exchange-rate-proxy.js`）

## 3. 命名規則

### 3.1 JSX コンポーネント

- **コンポーネント名**: PascalCase を使用
  ```jsx
  // 良い例
  function UserProfile() {...}
  const PortfolioChart = () => {...}
  
  // 悪い例
  function userProfile() {...}
  const portfolioChart = () => {...}
  ```

### 3.2 変数・関数名

- **変数・関数名**: camelCase を使用
  ```javascript
  // 良い例
  const userData = {...}
  function calculateTotal() {...}
  
  // 悪い例
  const UserData = {...}
  function CalculateTotal() {...}
  ```

- **boolean変数**: `is`, `has`, `should` などのプレフィックスを使用
  ```javascript
  // 良い例
  const isLoading = true;
  const hasError = false;
  const shouldRefresh = true;
  const isStock = true; // 個別株かどうかのフラグ
  ```

### 3.3 定数

- **定数**: 大文字のSNAKE_CASEを使用
  ```javascript
  // 良い例
  const MAX_RETRY_COUNT = 3;
  const DEFAULT_CURRENCY = 'JPY';
  const ALPHA_VANTAGE_URL = '/.netlify/functions/alpha-vantage-proxy';
  const FUND_TYPES = {
    STOCK: '個別株',
    ETF_JP: 'ETF（日本）',
    ETF_US: 'ETF（米国）'
  };
  ```

### 3.4 コンテキストとフック

- **コンテキスト**: `XxxContext` の形式を使用し、デフォルトエクスポート
  ```javascript
  // 良い例
  const AuthContext = createContext();
  export default AuthContext;
  export const AuthProvider = ({ children }) => {...};
  ```

- **カスタムフック**: `use` プレフィックスを使用し、両方のエクスポート形式を提供
  ```javascript
  // 良い例 - 両方のエクスポート形式
  export const useAuth = () => {...}
  export default useAuth;
  ```

### 3.5 イベントハンドラ

- **イベントハンドラ関数**: `handle` プレフィックスを使用
  ```javascript
  // 良い例
  const handleSubmit = () => {...}
  const handleInputChange = (e) => {...}
  const handleIncrementFee = (asset, amount) => {...}
  ```

### 3.6 ユーティリティ関数

- **ユーティリティ関数**: 目的が明確な名前を使用
  ```javascript
  // 良い例
  const formatCurrency = (amount, currency) => {...}
  const estimateAnnualFee = (ticker, name) => {...}
  const guessFundType = (ticker, name) => {...}
  ```

## 4. コードフォーマット

### 4.1 基本ルール

- **インデント**: 2スペースを使用
- **行の長さ**: 最大100文字（例外：URLs、長い文字列）
- **セミコロン**: すべての文の末尾にセミコロンを使用
- **括弧のスタイル**: 開始括弧は同じ行に配置

### 4.2 JSX フォーマット

- **要素の属性が多い場合**: 複数行に分割
  ```jsx
  // 良い例 (少数の属性)
  <Button type="primary" onClick={handleClick}>提出</Button>
  
  // 良い例 (多数の属性)
  <Button
    type="button"
    className={`px-4 py-2 rounded-md ${
      importFormat === 'json' ? 'bg-primary text-white' : 'bg-gray-200'
    }`}
    onClick={() => setImportFormat('json')}
    role="radio"
    aria-checked={importFormat === 'json'}
    disabled={isStock} // 個別株の場合は無効化
  >
    JSON
  </Button>
  ```

- **バッジコンポーネント**（追加）:
  ```jsx
  // ファンドタイプバッジ
  <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
    asset.fundType === FUND_TYPES.STOCK
      ? 'bg-gray-100 text-gray-800'
      : 'bg-blue-100 text-blue-800'
  }`}>
    {asset.fundType}
  </span>
  
  // 手数料情報バッジ
  <span className={`text-xs px-1.5 py-0.5 rounded ${
    asset.feeSource === '個別株'
      ? 'bg-gray-100 text-gray-800'
      : asset.feeSource === 'ユーザー設定' 
        ? 'bg-purple-100 text-purple-800' 
        : asset.feeIsEstimated 
          ? 'bg-yellow-100 text-yellow-800'
          : 'bg-green-100 text-green-800'
  }`}>
    {asset.feeSource}
  </span>
  ```

- **アクセシビリティ属性**:
  ```jsx
  // ラベルとコントロールの関連付け
  <label htmlFor="budget-input">追加予算</label>
  <input id="budget-input" type="number" />
  
  // ラジオグループ
  <div role="radiogroup" aria-labelledby="format-label">
    <span id="format-label">形式:</span>
    <button role="radio" aria-checked={true}>JSON</button>
    <button role="radio" aria-checked={false}>CSV</button>
  </div>
  ```

### 4.3 インポート文の整理

- **インポートの順序**:
  1. React関連（React, React Router）
  2. サードパーティライブラリ
  3. プロジェクト内モジュール（相対パス）
  4. ユーティリティとタイプ（新規）
  5. スタイル・アセット

  ```javascript
  // 良い例
  import React, { useState, useCallback } from 'react';
  import { useNavigate } from 'react-router-dom';
  
  import jwtDecode from 'jwt-decode';  // 注意: 最新形式でのインポート
  import { formatCurrency } from 'accounting';
  
  import { usePortfolioContext } from '../../hooks/usePortfolioContext';
  import Header from '../layout/Header';
  
  import { FUND_TYPES } from '../../utils/fundUtils'; // ユーティリティ関数からのタイプ
  
  import './styles.css';
  ```

## 5. React固有の規則

### 5.1 コンポーネント定義

- **関数コンポーネント**: アロー関数よりも関数宣言を優先
  ```jsx
  // 推奨
  function MyComponent() {
    return <div>...</div>;
  }
  ```

- **Props分割代入**: コンポーネント内で使用
  ```jsx
  // 良い例
  function UserCard({ name, email, avatar, isStock }) {
    return (
      <div>
        <img src={avatar} alt={name} />
        <h2>{name}</h2>
        <p>{email}</p>
        {isStock && <span className="badge">個別株</span>}
      </div>
    );
  }
  ```

### 5.2 Hooks の使用

- **useCallback, useMemo**: 適切に依存配列を定義
  ```jsx
  // 良い例
  const handleSubmit = useCallback(() => {
    submitData(formData);
  }, [formData, submitData]);
  ```

- **カスタムフックの命名**: 明確な目的を表す名前を使用
  ```jsx
  // 良い例
  export const usePortfolioContext = () => {...}
  export const useAuth = () => {...}
  export const useFundUtils = () => {...} // 新規: ファンドユーティリティフック
  ```

### 5.3 環境依存のライブラリ対応

- **jwt-decode v4の対応**: デフォルトインポートを使用
  ```javascript
  // jwt-decode v3/v4対応
  import jwtDecode from 'jwt-decode';
  
  // 使用例
  const decodedToken = jwtDecode(token);
  ```

## 6. 状態管理

### 6.1 Context API の使用

- **コンテキスト分離**: 関連する状態ごとに別々のコンテキストを使用
  - AuthContext: 認証関連
  - PortfolioContext: ポートフォリオデータ関連

- **Provider のカプセル化**: 専用のProviderコンポーネントを作成
  ```jsx
  export const AuthProvider = ({ children }) => {
    // 状態と関数の定義
    return (
      <AuthContext.Provider value={...}>
        {children}
      </AuthContext.Provider>
    );
  };
  ```

### 6.2 状態更新関数

- **イミュータブルな更新**: 常に新しいオブジェクトを返す
  ```javascript
  // 良い例
  setCurrentAssets(prev => 
    prev.map(item => 
      item.id === id 
      ? { ...item, holdings: parseFloat(parseFloat(holdings).toFixed(4)) || 0 } 
      : item
    )
  );
  ```

- **小数点位置の処理**: 数値の精度を保つために適切な方法を使用
  ```javascript
  // 小数点以下4桁まで保存するケース
  const value = parseFloat(parseFloat(rawValue).toFixed(4));
  
  // 小数点以下2桁まで保存するケース（手数料率など）
  const fee = parseFloat(parseFloat(rawValue).toFixed(2));
  ```

- **条件付き状態更新**（新規）: 条件に基づいて異なる更新を行う
  ```javascript
  // 個別株判定に基づく状態更新
  setCurrentAssets(prev => 
    prev.map(item => {
      if (item.id === id) {
        if (item.fundType === FUND_TYPES.STOCK || item.isStock) {
          // 個別株の場合は手数料を強制的に0に設定
          return {
            ...item,
            annualFee: 0,
            feeSource: '個別株',
            feeIsEstimated: false
          };
        } else {
          // その他のファンドの場合はユーザー指定の値を使用
          return {
            ...item,
            annualFee: parseFloat(parseFloat(fee).toFixed(2)) || 0,
            userSetFee: true,
            feeSource: 'ユーザー設定',
            feeIsEstimated: false
          };
        }
      }
      return item;
    })
  );
  ```

## 7. エラー処理

### 7.1 エラーキャッチと表示

- **try/catch**: 非同期処理では常に使用
  ```javascript
  try {
    const data = await fetchData();
    processData(data);
  } catch (error) {
    console.error('データ取得エラー:', error);
    setError('データの取得に失敗しました');
  }
  ```

- **ログ出力の強化**: デバッグ情報を十分に提供
  ```javascript
  try {
    console.log(`Attempting to fetch data for ${ticker} from Alpha Vantage`);
    const response = await axios.get(ALPHA_VANTAGE_URL, {
      params: { symbols: ticker },
      timeout: 5000 // タイムアウト設定
    });
    // 処理
  } catch (error) {
    console.error(`Error fetching ${ticker} from Alpha Vantage:`, error);
    console.log(`Trying fallback for ${ticker}`);
    // 代替処理
  }
  ```

### 7.2 入力バリデーション

- **早期リターン**: エラーケースを最初に処理
  ```javascript
  const submitForm = (data) => {
    if (!data.email) {
      setError('メールアドレスは必須です');
      return;
    }
    
    // 正常処理を続行
  };
  ```

- **特殊条件のチェック**（新規）:
  ```javascript
  // 個別株の手数料編集防止
  const handleIncrementFee = (asset, amount) => {
    // 個別株は手数料の変更不可
    if (asset.fundType === FUND_TYPES.STOCK || asset.isStock) {
      showMessage('個別株の手数料率は変更できません（常に0%）', 'warning');
      return;
    }
    
    // 通常の処理を続行
    const newValue = Math.max(0, (asset.annualFee || 0) + amount);
    updateAnnualFee(asset.id, parseFloat(newValue.toFixed(2)));
  };
  ```

### 7.3 API呼び出しのフォールバック処理

- **Alpha Vantage API使用とフォールバック**:
  ```javascript
  // Alpha Vantage APIからのデータ取得を試みる
  try {
    const result = await fetchFromAlphaVantage(ticker);
    return result;
  } catch (error) {
    console.error('Alpha Vantage API error:', error);
    
    // APIからのデータ取得に失敗した場合はフォールバック値を使用
    return generateFallbackData(ticker);
  }
  ```

- **タイムアウト設定**:
  ```javascript
  // タイムアウト付きの呼び出し
  const response = await axios.get(apiUrl, {
    params: { /* パラメータ */ },
    timeout: 15000 // 15秒タイムアウト
  });
  ```

- **レート制限対応**:
  ```javascript
  // Alpha Vantage APIのレート制限チェック
  if (response.data && response.data.Note && response.data.Note.includes('API call frequency')) {
    console.warn('Alpha Vantage API rate limit reached:', response.data.Note);
    return generateFallbackData(ticker); // レート制限に達した場合はフォールバック値を使用
  }
  ```

## 8. アクセシビリティ

### 8.1 基本原則

- **意味的なHTML**: 適切なHTML要素や属性を使用
  ```jsx
  // 良い例
  <button 
    type="button"
    onClick={handleClick}
    aria-label="閉じる"
    disabled={isDisabled}
  >
    <Icon name="close" />
  </button>
  ```

### 8.2 フォームアクセシビリティ

- **ラベル関連付け**: フォーム要素にはlabelを関連付け
  ```jsx
  // 良い例
  <div>
    <label htmlFor="email">メールアドレス</label>
    <input id="email" type="email" />
  </div>
  ```

- **グループ化と関連付け**: ラジオボタンなどのグループは適切に構造化
  ```jsx
  <div role="radiogroup" aria-labelledby="format-label">
    <span id="format-label">フォーマット:</span>
    <button role="radio" aria-checked={format === 'json'}>JSON</button>
    <button role="radio" aria-checked={format === 'csv'}>CSV</button>
  </div>
  ```

- **状態の視覚的表現**（新規）: 
  ```jsx
  // 個別株の場合は編集不可と視覚的に表現
  <button
    onClick={() => handleIncrementFee(asset, 0.01)}
    className="p-1 bg-green-100 text-green-700 rounded text-xs"
    disabled={asset.fundType === FUND_TYPES.STOCK || asset.isStock}
  >
    +
  </button>
  
  // 非活性要素のスタイリング
  <tr className={asset.isStock || asset.fundType === FUND_TYPES.STOCK ? 'bg-gray-50' : ''}>
    {/* 行の内容 */}
  </tr>
  ```

## 9. ESLint設定と解析ツール

### 9.1 ESLint設定（更新版）

```json
{
  "extends": [
    "react-app",
    "react-app/jest"
  ],
  "rules": {
    "no-console": ["warn", { "allow": ["warn", "error", "log"] }],
    "no-unused-vars": "warn",
    "react-hooks/rules-of-hooks": "error",
    "react-hooks/exhaustive-deps": "warn",
    "jsx-a11y/label-has-associated-control": "off"
  }
}
```

### 9.2 選択的アクセシビリティルールの無効化

特定のコンポーネントやファイルで特定のルールだけを無効にする場合:

```javascript
// 特定の行でESLintルールを無効化
// eslint-disable-next-line jsx-a11y/label-has-associated-control
<label className="...">ラベルテキスト</label>

// ファイル全体でルールを無効化
/* eslint-disable jsx-a11y/label-has-associated-control */
```

## 10. APIとサービス連携

### 10.1 プロキシ設定

setupProxy.js での効果的なプロキシ設定:

```javascript
const { createProxyMiddleware } = require('http-proxy-middleware');

module.exports = function(app) {
  app.use(
    '/.netlify/functions/',
    createProxyMiddleware({
      target: 'http://localhost:9000',
      pathRewrite: {
        '^/\\.netlify/functions': ''
      },
      changeOrigin: true
    })
  );
};
```

### 10.2 外部APIコール

axios を使用した標準的なAPI呼び出し（Alpha Vantageプライマリ版）:

```javascript
import axios from 'axios';

// Alpha Vantage API呼び出し関数（プライマリソース）
const fetchMarketData = async (ticker) => {
  try {
    console.log(`Attempting to fetch data for ${ticker} from Alpha Vantage`);
    const response = await axios.get(`/.netlify/functions/alpha-vantage-proxy`, {
      params: {
        function: 'GLOBAL_QUOTE',
        symbol: ticker,
        apikey: ALPHA_VANTAGE_KEY // REACT_APP_ALPHA_VANTAGE_API_KEY から取得
      },
      timeout: 15000, // 15秒タイムアウト
      headers: {
        'Cache-Control': 'no-cache',
        'Pragma': 'no-cache',
        'Expires': '0'
      }
    });
    
    // レスポンス検証
    if (response.data && response.data['Global Quote'] && response.data['Global Quote']['05. price']) {
      const quoteData = response.data['Global Quote'];
      const price = parseFloat(quoteData['05. price']);
      
      // ファンド情報の取得・判定
      const fundType = guessFundType(ticker);
      const feeInfo = estimateAnnualFee(ticker);
      const isStock = fundType === FUND_TYPES.STOCK;
      
      // レスポンスの構築
      return {
        success: true,
        data: {
          id: ticker,
          name: ticker,
          ticker: ticker,
          exchangeMarket: ticker.includes('.T') ? 'Japan' : 'US',
          price: price,
          currency: ticker.includes('.T') ? 'JPY' : 'USD',
          annualFee: isStock ? 0 : feeInfo.fee, // 個別株は常に0%
          fundType: fundType,
          isStock: isStock,
          feeSource: isStock ? '個別株' : feeInfo.source,
          feeIsEstimated: isStock ? false : feeInfo.isEstimated,
          source: 'Alpha Vantage'
        }
      };
    }
    
    // データが取得できなかった場合はフォールバック値を使用
    return generateFallbackData(ticker);
  } catch (error) {
    console.error('Alpha Vantage API error:', error);
    console.log(`Error details: ${error.response?.status || 'No status'} - ${error.message}`);
    
    // エラー発生時はフォールバック値を使用
    return generateFallbackData(ticker);
  }
};
```

### 10.3 環境変数の利用

環境変数名の統一と利用方法:

```javascript
// フロントエンド（React）での環境変数利用
const ALPHA_VANTAGE_KEY = process.env.REACT_APP_ALPHA_VANTAGE_API_KEY || 'GC4EBI5YHFKOJEXY';

// サーバーレス関数での環境変数利用
const apiKey = process.env.ALPHA_VANTAGE_API_KEY || 'GC4EBI5YHFKOJEXY';
```

### 10.4 ファンドタイプと手数料の判定（新規）

```javascript
// ファンドタイプ判定
export function guessFundType(ticker, name = '') {
  ticker = ticker.toUpperCase();
  name = name.toLowerCase();
  
  // 日本市場のティッカー判定
  const isJapanese = ticker.includes('.T');
  
  // 個別株の判定ロジック
  const isJapaneseStock = isJapanese && !(/^[1-9]\d{3}\.T$/.test(ticker));
  
  // ETFの判定ロジック
  const isETF = (isJapanese && /^[1-9]\d{3}\.T$/.test(ticker)) || /* その他の条件 */;
  
  // 判定結果の返却
  if (isJapaneseStock || /* その他の個別株判定条件 */) {
    return FUND_TYPES.STOCK;
  } else if (isETF) {
    return isJapanese ? FUND_TYPES.ETF_JP : FUND_TYPES.ETF_US;
  } else {
    // 他のファンドタイプの判定
  }
}

// 手数料率推定
export function estimateAnnualFee(ticker, name = '') {
  ticker = ticker.toUpperCase();
  
  // 特定ティッカーの既知の手数料
  if (TICKER_SPECIFIC_FEES[ticker]) {
    return {
      fee: TICKER_SPECIFIC_FEES[ticker],
      source: 'ティッカー固有の情報',
      isEstimated: false
    };
  }
  
  // ファンドタイプから手数料を推定
  const fundType = guessFundType(ticker, name);
  
  // 個別株の場合は必ず0を返す
  if (fundType === FUND_TYPES.STOCK) {
    return {
      fee: 0,
      fundType: FUND_TYPES.STOCK,
      source: '個別株',
      isEstimated: false
    };
  }
  
  const fee = FUND_TYPE_FEES[fundType] || FUND_TYPE_FEES[FUND_TYPES.UNKNOWN];
  
  return {
    fee,
    fundType,
    source: 'ファンドタイプからの推定',
    isEstimated: true
  };
}
```

## 11. データバリデーションと検証（新規）

### 11.1 データインポート時の検証

```javascript
// インポートデータの検証
const importData = (data) => {
  if (!data) return { success: false, message: 'データが無効です' };
  
  try {
    // 必須フィールドの検証
    if (data.baseCurrency) setBaseCurrency(data.baseCurrency);
    if (data.exchangeRate) setExchangeRate(data.exchangeRate);
    
    // データのインポート前に個別株の手数料率を0に確実に設定
    if (Array.isArray(data.currentAssets)) {
      const fixedAssets = data.currentAssets.map(asset => {
        const isStock = asset.fundType === FUND_TYPES.STOCK || asset.isStock;
        if (isStock) {
          return {
            ...asset,
            annualFee: 0,
            feeSource: '個別株',
            feeIsEstimated: false,
            isStock: true
          };
        }
        return asset;
      });
      setCurrentAssets(fixedAssets);
    }
    
    if (Array.isArray(data.targetPortfolio)) setTargetPortfolio(data.targetPortfolio);
    
    return { success: true, message: 'データをインポートしました' };
  } catch (error) {
    console.error('データのインポートに失敗しました', error);
    return { success: false, message: 'データのインポートに失敗しました' };
  }
};
```

### 11.2 銘柄タイプの整合性確保

```javascript
// 初期化時に個別株の手数料を確実に0に設定
useEffect(() => {
  setCurrentAssets(prev => prev.map(asset => {
    const isStock = asset.fundType === FUND_TYPES.STOCK || asset.isStock;
    if (isStock && asset.annualFee !== 0) {
      return {
        ...asset,
        annualFee: 0,
        feeSource: '個別株',
        feeIsEstimated: false,
        isStock: true
      };
    }
    return asset;
  }));
}, []);
```

## 改訂履歴

| バージョン | 日付 | 変更内容 | 担当者 |
|----------|-----|---------|-------|
| 1.0      | 2025/03/16 | 初版作成 | |
| 1.1      | 2025/03/17 | jwt-decode対応、アクセシビリティ対応、ESLint設定更新 | |
| 1.2      | 2025/03/18 | データ取得フォールバック機構、環境変数名統一、ログ出力強化 | |
| 1.3      | 2025/03/20 | ファンドタイプ判定と年間手数料計算に関する規約追加、個別株の取り扱い追加 | |
